<html>
<head>
	<script src="https://cdn.firebase.com/js/client/2.4.1/firebase.js"></script>
	<script src="paper-full.js"></script>
	<style>
		body{
			width:1600px;
		}
		canvas{
			border:1px solid #999;
		}
		body > div{
			display:inline-block;
			vertical-align:top;
		}
		path{
			stroke:#000;
			stroke-width:5px;
			fill:none;

		}
		table{
			border:0px solid #999;
			font-size:10px;
		}
		#table3{
			padding-left:14px;
		}
		td{
			width:20px;
			height:20px;
		}
		#table2 td{
			background:#f88;
		}
		#table2 td.done{
			background:#8f8;
		}
		#table1 td:hover, #table2 td:hover{
			background:#5bf;
			outline:2px solid #09e;
		}
		#table2 td.dead{
			background:#eee;
			outline:none;
			/*outline:1px solid #f00;*/
		}
		svg{
			vertical-align:top;
			height:20px;
			margin:auto;
		}
	</style>
</head>
<body>
	<div>
		<button onclick="undo()">undo</button>
		<button onclick="redo()">redo</button>
		<button onclick="clr()">clear</button>
		<br><br>
		<canvas id="myCanvas" width="225" height="200"></canvas>
		<br><br>
		letters (e.g., "a,b"): <input type="text" id="letters"/>
		<br><br>
		(please list in alphabetical order)
		<br>
		(case sensitive)
		<br><br>
		<button onclick="submit()">submit</button>
		<br><br>
		(feel free to replace green ones if you think you have something that looks better. I will try to implement flagging soon so that we can flag which ones can be replaced and which ones shouldn't)
	</div>
	<div>
		<table id="table1"></table>
		<table id="table3"></table>
		<table id="table2"></table>
	</div>
	<!--<svg id="svg">
		<path stroke="#000" stroke-width="5px" stroke-linecap="round" id="path" fill="none"/>
	</svg>-->
	<script>
		var ref = new Firebase("https://perception.firebaseio.com/");

		/*
		
		TODO
		- implement flagging in editor
		- visualize others than just singles
		- analyze most common combinations needed
		- create algorithm that is better

		*/

		var canvas = document.getElementById('myCanvas');

		var letters = document.querySelector('#letters');
		var svg = document.querySelector('#svg');

		var table1 = document.querySelector('#table1');
		var table2 = document.querySelector('#table2');
		var table3 = document.querySelector('#table3');

		//canvas.width =
		// Create an empty project and a view for the canvas:
		paper.setup(canvas);
		// Create a Paper.js Path to draw a line into it:
		
		/*var rect = new paper.Path.Rectangle([-1, -1], [150, 402]);
		var rect2 = new paper.Path.Rectangle([251, -1], [150, 402]);
		rect.fillColor="#eee"
		rect.strokeColor="#999"
		rect2.fillColor="#eee"
		rect2.strokeColor="#999"*/
		var line = new paper.Path.Line([0,75],[302,75])
		line.strokeColor="#999"
		line.dashArray = [10,10]
		var line = new paper.Path.Line([0,125],[302,125])
		line.strokeColor="#999"

		var line = new paper.Path.Rectangle([-1,-1],[304,26])
		line.strokeColor="#999"
		line.fillColor="#eee"
		var line = new paper.Path.Rectangle([-1,177],[304,26])
		line.strokeColor="#999"
		line.fillColor="#eee"

		var line = new paper.Path.Rectangle([75,25],[75,152])
		line.strokeColor="#f00"
		
		paper.view.update();

		var paths = []
		var undos = []

		var alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

		var mousedown = false;

		function onMouseDown(event) {
			mousedown = true;

			// Create a new path and set its stroke color to black:
			paths.push(new paper.Path({
				segments: [[event.clientX - canvas.offsetLeft + document.body.scrollLeft, event.clientY - canvas.offsetTop + document.body.scrollTop]],
				strokeColor: 'black',
				strokeWidth: 3
			}));

			undos = []
		}

		// While the user drags the mouse, points are added to the path
		// at the position of the mouse:
		function onMouseMove(event) {
			if (mousedown) {
				paths[paths.length-1].add([event.clientX - canvas.offsetLeft + document.body.scrollLeft, event.clientY - canvas.offsetTop + document.body.scrollTop]);
			}
		}

		// When the mouse is released, we simplify the path:
		function onMouseUp(event) {
			if (mousedown) {
				mousedown = false;

				var segmentCount = paths[paths.length-1].segments.length;

				// When the mouse is released, simplify it:
				paths[paths.length-1].simplify(10);
			}
		}

		function undo(){
			if(paths.length > 0){
				paths[paths.length-1].remove()
				undos.push(paths[paths.length-1])
				paths.pop()
			}
			paper.view.update()
		}

		function redo(){
			if(undos.length > 0){
				paths.push(new paper.Path({
					segments: undos[undos.length-1].getSegments(),
					strokeColor: 'black',
					strokeWidth: 3
				}));
				undos.pop()
				paper.view.update()
			}
		}

		function clr(){
			paths.forEach(function(p){
				p.remove()
			})
			paths = []
			undos = []
			paper.view.update()
		}

		function createTd(title,r,c){
			var td = document.createElement('td');
			if(r != undefined && r + 1 > c){
				td.classList.add('dead')
			}else{
				td.setAttribute('title', title)
			}
			var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
			svg.setAttribute('viewBox', '75 25 75 150')
			var path = document.createElementNS("http://www.w3.org/2000/svg","path");
			svg.appendChild(path);
			td.appendChild(svg);
			return td
		}

		for(var r = 0; r < 2; r++){
			var tr = document.createElement('tr');
			for(var c = 0; c < 26; c++){
				tr.appendChild(createTd(alphabet[r*26+c]))
			}
			table1.appendChild(tr)
		}

		for(var r = 0; r < 52; r++){
			var tr = document.createElement('tr');
			tr.textContent = alphabet[r]
			for(var c = 0; c < 52; c++){
				tr.appendChild(createTd(alphabet[r]+', '+alphabet[c], r, c))
			}
			table2.appendChild(tr)
		}

		var tr = document.createElement('tr');
		for(var c = 0; c < 52; c++){
			var td = document.createElement('td');
			td.textContent = alphabet[c]
			tr.appendChild(td)
		}
		table3.appendChild(tr)

		ref.child('data').on('child_added', function(snapshot){
			var k = snapshot.key().split(',').sort()
			var td;
			if (k.length == 1) {
				td = table1.children[(k[0].toUpperCase() == k[0])+0].children[alphabet.indexOf(k[0].toLowerCase())]
			} else if (k.length == 2) {
				td = table2.children[alphabet.indexOf(k[0])].children[alphabet.indexOf(k[1])]
			}else{
				return
			}
			td.classList.add('done')
			td.querySelector('svg path').setAttribute('d', snapshot.val())
		})

		function submit(){
			if (letters.value != '') {
				combpath = paths.map(function(p){return p.getPathData()}).join('')

				ref.child('data/'+letters.value).set(combpath)

				letters.value = ''

				clr()
			}
		}

		canvas.addEventListener('mousedown', onMouseDown)
		window.addEventListener('mousemove', onMouseMove)
		window.addEventListener('mouseup', onMouseUp)
	</script>
</body>
</html>